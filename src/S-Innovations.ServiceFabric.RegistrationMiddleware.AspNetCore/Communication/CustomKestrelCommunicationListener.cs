using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Hosting.Server.Features;
using Microsoft.ServiceFabric.Services.Communication.Runtime;
using Polly;
using Polly.Retry;
using System;
using System.Fabric;
using System.Fabric.Description;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace SInnovations.ServiceFabric.RegistrationMiddleware.AspNetCore.Communication
{
    /// <summary>
    /// Base class for creating AspNetCore based communication listener for Service Fabric stateless or stateful service.
    /// </summary>
    public abstract class AspNetCoreCommunicationListener : ICommunicationListener
    {
        private readonly Func<string, AspNetCoreCommunicationListener, IWebHost> build;
        private IWebHost webHost;
        private string urlSuffix = null;
        private readonly ServiceContext serviceContext;
        private bool configuredToUseUniqueServiceUrl = false;

        /// <summary>
        /// The context of the service for which this communication listener is being constructed.
        /// </summary>
        public ServiceContext ServiceContext
        {
            get { return this.serviceContext; }
        }

        /// <summary>
        /// Configures the listener to use UniqueServiceUrl by appending a urlSuffix PartitionId and ReplicaId.
        /// It helps in scenarios when ServiceA listening on a node on port X moves and another Service takes its place on the same node and starts using the same port X,
        /// The UniqueServiceUrl in conjunction with middleware rejects requests meant for serviceA arriving at ServiceB.
        /// Example:
        /// Service A is dynamically assigned port 30000 on node with IP 10.0.0.1, it listens on http://+:30000/ and reports to Naming service http://10.0.0.1:30000/serviceName-A/partitionId-A/replicaId-A
        /// Client resolves URL from NS: http://10.0.0.1:30000/serviceName-A/partitionId-A/replicaId-A and sends a request, Service A compares URL path segments to its own service name, partition ID, replica ID, finds they are equal, serves request.
        /// Now Service A moves to a different node and Service B comes up at the node with IP 10.0.0.1 and is dynamically assigned port 30000.
        /// Service B listens on: http://+:30000/ and reports to NS http://10.0.0.1:30000/serviceName-B/partitionId-B/replicaId-B, Client for Service a sends request to http://10.0.0.1:30000/serviceName-A/partitionId-A/replicaId-A
        /// Service B compares URL path segments to its own service name, partition ID, replica ID, finds they do not match, ends the request and responds with HTTP 410. Client receives 410 and re-resolves for service A.
        /// </summary>
        internal void ConfigureToUseUniqueServiceUrl()
        {
            if (!this.configuredToUseUniqueServiceUrl)
            {
                this.urlSuffix = string.Format(CultureInfo.InvariantCulture, "/{0}/{1}", this.serviceContext.PartitionId, this.serviceContext.ReplicaOrInstanceId);

                if (this.ServiceContext is StatefulServiceContext)
                {
                    // For stateful service, also append a Guid, Guid makes the url unique in scenarios for stateful services when Listener is 
                    // created to support read on secondary and change role happens from Primary->Secondary for the replica.
                    urlSuffix += "/" + Guid.NewGuid();
                }

                this.configuredToUseUniqueServiceUrl = true;
            }
        }

        /// <summary>
        /// UrlSuffix to be used based on <see cref="ServiceFabricIntegrationOptions"/> specified in
        /// <see cref="WebHostBuilderServiceFabricExtension.UseServiceFabricIntegration"/>.
        /// </summary>
        public string UrlSuffix
        {
            get
            {
                return this.urlSuffix;
            }
        }

        /// <summary>
        /// Constructs a AspNetCore communication listener.
        /// </summary>
        /// <param name="serviceContext">The context of the service for which this communication listener is being constructed.</param>
        /// <param name="build">Delegate to build Microsoft.AspNetCore.Hosting.IWebHost, endpoint url generated by the listener is given as input to this delegate.
        /// This gives the flexibility to change the url before creating Microsoft.AspNetCore.Hosting.IWebHost if needed.</param>
        public AspNetCoreCommunicationListener(ServiceContext serviceContext, Func<string, AspNetCoreCommunicationListener, IWebHost> build)
        {
            if (serviceContext == null)
            {
                throw new ArgumentNullException("serviceContext");
            }

            if (build == null)
            {
                throw new ArgumentNullException("build");
            }

            this.build = build;
            this.serviceContext = serviceContext;
            this.urlSuffix = string.Empty;
        }

        /// <summary>
        /// This method causes the communication listener to close. Close is a terminal state and
        /// this method causes the transition to close ungracefully. Any outstanding operations
        /// (including close) should be canceled when this method is called.
        /// </summary>
        public virtual void Abort()
        {
            if (this.webHost != null)
            {
            
                this.webHost.Dispose();
            }
        }

        /// <summary>
        /// This method causes the communication listener to close. Close is a terminal state and 
        /// this method allows the communication listener to transition to this state in a graceful manner.
        /// </summary>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>
        /// A <see cref="System.Threading.Tasks.Task">Task</see> that represents outstanding operation.
        /// </returns>
        public virtual Task CloseAsync(CancellationToken cancellationToken)
        {
            if (this.webHost != null)
            {
                this.webHost.Dispose();
            }

            return Task.FromResult(true);
        }

        AsyncRetryPolicy retry = Policy
              .Handle<Exception>()
              .WaitAndRetryAsync(new[]
              {
                TimeSpan.FromSeconds(1),
                TimeSpan.FromSeconds(2),
                TimeSpan.FromSeconds(4),
                TimeSpan.FromSeconds(8),
     
              });
        /// <summary>
        /// This method causes the communication listener to be opened. Once the Open
        /// completes, the communication listener becomes usable - accepts and sends messages.
        /// </summary>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>
        /// A <see cref="System.Threading.Tasks.Task">Task</see> that represents outstanding operation. The result of the Task is
        /// is endpoint string on which IWebHost is listening.
        /// </returns>
        public virtual Task<string> OpenAsync(CancellationToken cancellationToken)
        {
            this.webHost = this.build(this.GetListenerUrl(), this);

            if (this.webHost == null)
            {
                throw new InvalidOperationException("webhost is null");
            }


            return retry.ExecuteAsync(async () =>
            {

                try
                {
                    await this.webHost.StartAsync();


                    var url = this.webHost.ServerFeatures.Get<IServerAddressesFeature>().Addresses
                            .Select(a => a.Replace("://+", "://" + this.serviceContext.NodeContext.IPAddressOrFQDN)).FirstOrDefault();

                    if (url == null)
                    {
                        throw new InvalidOperationException("no url");
                    }

                    var publishAddress = this.serviceContext.PublishAddress;

                    if (url.Contains("://+:"))
                    {
                        url = url.Replace("://+:", $"://{publishAddress}:");
                    }
                    else if (url.Contains("://[::]:"))
                    {
                        url = url.Replace("://[::]:", $"://{publishAddress}:");
                    }

                    // When returning url to naming service, add UrlSuffix to it.
                    // This UrlSuffix will be used by middleware to:
                    //    - drop calls not intended for the service and return 410.
                    //    - modify Path and PathBase in Microsoft.AspNetCore.Http.HttpRequest to be sent correctly to the service code.
                    url = url.TrimEnd(new[] { '/' }) + this.UrlSuffix;

                    return url;
                }catch(Exception )
                {
                    throw;
                }
            });
        }

        /// <summary>
        /// Retrieves the endpoint resource with a given name from the service manifest.
        /// </summary>
        /// <param name="endpointName">The name of the endpoint.</param>
        /// <returns>The endpoint resource with the specified name.</returns>
        protected EndpointResourceDescription GetEndpointResourceDescription(string endpointName)
        {
            if (endpointName == null)
            {
                throw new ArgumentNullException("endpointName");
            }

            if (!this.serviceContext.CodePackageActivationContext.GetEndpoints().Contains(endpointName))
            {
                throw new InvalidOperationException(string.Format("Endpoint {0} not found", endpointName));
            }

            return this.serviceContext.CodePackageActivationContext.GetEndpoint(endpointName);
        }

        /// <summary>
        /// Gets url for this listener to be used with Web Server.
        /// </summary>
        /// <returns>url for this listener to be used with Web Server.</returns>
        protected abstract string GetListenerUrl();
    }
    /// <summary>
    /// An AspNetCore Kestrel based communication listener for Service Fabric stateless or stateful service.
    /// </summary>
    public class KestrelCommunicationListener : AspNetCoreCommunicationListener
    {
        private readonly string endpointName;

        /// <summary>
        /// Constructs a AspNetCore Kestrel based communication listener using a default address with http protocol and port 0.
        /// Kestrel will dynamically bind to an unspecified, available port when port 0 is specified in url.
        /// </summary>
        /// <param name="serviceContext">The context of the service for which this communication listener is being constructed.</param>
        /// <param name="build">Delegate to build Microsoft.AspNetCore.Hosting.IWebHost, endpoint url generated by the listener is given as input to this delegate.
        /// This gives the flexibility to change the url before creating Microsoft.AspNetCore.Hosting.IWebHost if needed.</param>
        public KestrelCommunicationListener(ServiceContext serviceContext, Func<string, AspNetCoreCommunicationListener, IWebHost> build)
            : this(serviceContext, null, build)
        {
        }

        /// <summary>
        /// Constructs a AspNetCore Kestrel based communication listener.
        /// </summary>
        /// <param name="serviceContext">The context of the service for which this communication listener is being constructed.</param>
        /// <param name="endpointName">Name of endpoint resource defined in service manifest that should be used to create the address for listener.
        /// Protocol and port specified in this endpoint is used to create the url.
        /// If the endpointName is null, a default address with http protocol and port 0 will be used.
        /// Kestrel will dynamically bind to an unspecified, available port when port 0 is specified in url.
        /// If the specified endpointName is not found in service manifest, an InvalidOperationException indicating this will be thrown.</param>
        /// <param name="build">Delegate to build Microsoft.AspNetCore.Hosting.IWebHost, endpoint url generated by the listener is given as input to this delegate.
        /// This gives the flexibility to change the url before creating Microsoft.AspNetCore.Hosting.IWebHost if needed.</param>
        public KestrelCommunicationListener(ServiceContext serviceContext, string endpointName, Func<string, AspNetCoreCommunicationListener, IWebHost> build)
            : base(serviceContext, build)
        {
            if (endpointName != null && endpointName.Equals(string.Empty))
            {
                throw new ArgumentException("Empty Endpoint");
            }

            this.endpointName = endpointName;
        }


        /// <summary>
        /// Gets url for the listener. Listener url is created using the endpointName passed in the constructor.
        /// If the endpointName was null, a default url with http protocol and port zero is returned.
        /// </summary>
        /// <returns>url for the listener.</returns>
        protected override string GetListenerUrl()
        {
            // url with WebServer is always registered as http://+:port.
            var listenUrl = "http://+:0";

            // Get protocol and port from endpoint resource if specified.
            if (this.endpointName != null)
            {
                var serviceEndpoint = this.GetEndpointResourceDescription(this.endpointName);
                listenUrl = string.Format(CultureInfo.InvariantCulture, "{0}://+:{1}",
                    serviceEndpoint.Protocol.ToString().ToLower(), serviceEndpoint.Port);
            }

            return listenUrl;
        }
    }

    //public class CustomKestrelCommunicationListener : KestrelCommunicationListener
    //{
    //    private readonly ServiceContext _serviceContext;
    //    public CustomKestrelCommunicationListener(ServiceContext serviceContext, string serviceEdpoint, Func<string, AspNetCoreCommunicationListener, IWebHost> build) : base(serviceContext, serviceEdpoint, build)
    //    {
    //        _serviceContext = serviceContext;           
    //    }        

    //    public override async Task<string> OpenAsync(CancellationToken cancellationToken)
    //    {
    //        try
    //        {
    //            var url = await base.OpenAsync(cancellationToken).ConfigureAwait(false);

    //            return url.Replace("[::]", _serviceContext.NodeContext.IPAddressOrFQDN);
    //        }catch(Exception ex)
    //        {
    //            throw;
    //        }
    //    }
    //}
}
